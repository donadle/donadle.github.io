<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式（一）</title>
      <link href="/2025/12/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/12/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、设计模式的来由：从”重复造轮子”到”站在巨人肩膀上”"><a href="#一、设计模式的来由：从”重复造轮子”到”站在巨人肩膀上”" class="headerlink" title="一、设计模式的来由：从”重复造轮子”到”站在巨人肩膀上”"></a>一、设计模式的来由：从”重复造轮子”到”站在巨人肩膀上”</h2><p>“设计模式”最早用于建筑领域的设计中。1977 年，美国著名建筑大师、 加利福尼亚大学伯克利分校 环境结构中心主任<strong>克里斯托夫·亚历山大</strong>（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造（A Pattern Language: Towns Building Construction）中描述了一些常见的 建筑设计 问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。</p><h3 id="1-早期软件开发的困境"><a href="#1-早期软件开发的困境" class="headerlink" title="1. 早期软件开发的困境"></a>1. 早期软件开发的困境</h3><p>想象一下，几十年前，软件工程师们就像一群独自在森林里建房子的工匠。每个人都用自己的方法：有人先建屋顶再建墙、有人先打地基再砌墙，遇到同样的问题（比如”如何让房子更稳固”），每个人都要重新思考解决方案</p><p>这就导致了：</p><ul><li><strong>重复劳动</strong>：同样的问题，不同的人重复解决</li><li><strong>质量参差不齐</strong>：有些人建的房子很稳固，有些人建的房子容易倒塌</li><li><strong>学习成本高</strong>：新人要花很长时间才能掌握”正确”的建造方法</li></ul><h3 id="2-“四人组”的突破"><a href="#2-“四人组”的突破" class="headerlink" title="2. “四人组”的突破"></a>2. “四人组”的突破</h3><p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。</p><p><strong>这就像</strong>：</p><ul><li>一群经验丰富的建筑师把最好的建筑技巧总结成”建筑模式手册”</li><li>里面记录了”如何在地震多发区建房子”、”如何让高楼更稳固”等经过验证的最佳实践</li></ul><p>从此，”设计模式”这个概念正式诞生，软件工程从”手工作坊”走向了”规范化工程”。</p><h2 id="二、设计模式的概念：什么是设计模式？"><a href="#二、设计模式的概念：什么是设计模式？" class="headerlink" title="二、设计模式的概念：什么是设计模式？"></a>二、设计模式的概念：什么是设计模式？</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><p><strong>设计模式 &#x3D; 针对特定问题的经过验证的最佳解决方案模板</strong></p><blockquote><p>想象你是一个餐厅厨师：因为高峰期客人太多、点单混乱，所以采用”叫号系统” + “分区域服务”，最后上菜速度提升50%，客户满意度提高。在软件中，设计模式就是这样的”厨房管理经验”，但针对的是软件设计问题。</p></blockquote><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h3><ul><li><strong>不是代码</strong>：不是可以直接拷贝粘贴的代码片段</li><li><strong>是思想</strong>：是一种设计思想和解决方案的描述</li><li><strong>可复用</strong>：可以在不同项目中重复使用</li><li><strong>经过验证</strong>：是无数开发者实践检验过的</li></ul><h2 id="三、设计模式的必要性：为什么我们需要它？"><a href="#三、设计模式的必要性：为什么我们需要它？" class="headerlink" title="三、设计模式的必要性：为什么我们需要它？"></a>三、设计模式的必要性：为什么我们需要它？</h2><h3 id="1-解决”软件危机”"><a href="#1-解决”软件危机”" class="headerlink" title="1. 解决”软件危机”"></a>1. 解决”软件危机”</h3><p>早期软件项目经常面临超期交付、预算超支、质量低下、难以维护。而<strong>设计模式的作用</strong>就像医学中的”标准治疗方案”，让软件开发变得更可控。</p><h3 id="2-具体好处"><a href="#2-具体好处" class="headerlink" title="2. 具体好处"></a>2. 具体好处</h3><p>正确使用设计模式具有以下优点。</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><h2 id="四、设计模式的门派：设计模式有哪些类别？"><a href="#四、设计模式的门派：设计模式有哪些类别？" class="headerlink" title="四、设计模式的门派：设计模式有哪些类别？"></a>四、设计模式的门派：设计模式有哪些类别？</h2><p>设计模式主要分为三大类，用”建造房子”来比喻就是：</p><h3 id="1-创建型模式（Creational-Patterns）"><a href="#1-创建型模式（Creational-Patterns）" class="headerlink" title="1. 创建型模式（Creational Patterns）"></a>1. 创建型模式（Creational Patterns）</h3><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p><p><strong>核心问题</strong>：对象如何被创建？</p><p><strong>比喻</strong>：房子的”建造方式”是现场一砖一瓦砌起来？（简单工厂），还是用预制板组装？（建造者模式），还是复制一个现成的？（原型模式）。</p><p><strong>常见模式</strong>：</p><ul><li><strong>Singleton（单例模式）</strong>：确保一个类只有一个实例<ul><li><strong>例子</strong>：一个班级只有一个班主任，整个学校共享这个班主任对象</li></ul></li><li><strong>Factory（工厂模式）</strong>：把对象创建封装起来<ul><li><strong>例子</strong>：汽车工厂生产不同品牌的车，客户不用关心具体怎么造</li></ul></li><li><strong>Builder（建造者模式）</strong>：分步骤构建复杂对象<ul><li><strong>例子</strong>：组装电脑，先选CPU，再选内存，最后组装</li></ul></li></ul><h3 id="2-结构型模式（Structural-Patterns）"><a href="#2-结构型模式（Structural-Patterns）" class="headerlink" title="2. 结构型模式（Structural Patterns）"></a>2. 结构型模式（Structural Patterns）</h3><p><strong>核心问题</strong>：类和对象如何组合成更大的结构？</p><p><strong>比喻</strong>：房子的”内部结构设计”，即如何把房间、楼梯、走廊组合成合理的布局，或如何让不同材料（砖、木、钢）协同工作</p><p><strong>常见模式</strong>：</p><ul><li><strong>Adapter（适配器模式）</strong>：让不兼容的接口能够一起工作<ul><li><strong>例子</strong>：手机充电器适配器，让Type-C接口的手机能用USB-A接口充电</li></ul></li><li><strong>Decorator（装饰器模式）</strong>：动态地给对象添加功能<ul><li><strong>例子</strong>：给咖啡添加糖、牛奶、奶油，每种配料都是一个装饰器</li></ul></li><li><strong>Facade（外观模式）</strong>：为复杂系统提供简单接口<ul><li><strong>例子</strong>：电脑开机按钮，背后是复杂的启动过程，但用户只需要按一个按钮</li></ul></li></ul><h3 id="3-行为型模式（Behavioral-Patterns）"><a href="#3-行为型模式（Behavioral-Patterns）" class="headerlink" title="3. 行为型模式（Behavioral Patterns）"></a>3. 行为型模式（Behavioral Patterns）</h3><p><strong>核心问题</strong>：对象之间如何交互和分配职责？</p><p><strong>比喻</strong>：房子里的”人员分工和协作”。谁负责开门？谁负责做饭？如何协调工作？</p><p><strong>常见模式</strong>：</p><ul><li><strong>Observer（观察者模式）</strong>：对象间的一对多依赖关系<ul><li><strong>例子</strong>：微信公众号，粉丝关注后，作者发新文章，所有粉丝都能收到通知</li></ul></li><li><strong>Strategy（策略模式）</strong>：定义一系列算法，让它们可以互相替换<ul><li><strong>例子</strong>：导航软件中的路线策略：最快路线、最短路线、避开高速</li></ul></li><li><strong>Command（命令模式）</strong>：将请求封装成对象<ul><li><strong>例子</strong>：餐厅点餐，服务员把你的订单封装成”命令”传递给厨房</li></ul></li></ul><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>设计模式就像武术中的”套路”——初学者需要学习标准套路，但真正的高手能够灵活运用，甚至创造新的套路。<strong>记住：模式是工具，不是枷锁。</strong> </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DeepSeek思考模式下的工具调用与流式输出</title>
      <link href="/2025/12/19/DeepSeek%E6%80%9D%E8%80%83%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/"/>
      <url>/2025/12/19/DeepSeek%E6%80%9D%E8%80%83%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="DeepSeek思考模式下的工具调用与流式输出"><a href="#DeepSeek思考模式下的工具调用与流式输出" class="headerlink" title="DeepSeek思考模式下的工具调用与流式输出"></a>DeepSeek思考模式下的工具调用与流式输出</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，也就是12月1日，DeepSeek的api更新到了V3.2，增加了思考模式下调用工具的能力，正好项目也有把原来的RAG换成Agentic RAG的意向。在写完这个功能后，找机会记录一下其中遇到的一些情况。</p><p><img src="/2025/07/15/hello-world/%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/1.png"></p><h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>首先我用DeepSeek和langchain搓了一个简易的智能体框架，但是有如下缺点：</p><ul><li>只能使用stream方法只能分步输出，即完成一步操作，将结果一次完整输出。不符合预想的流式输出格式。</li><li>没有输出思考内容。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RagAgent</span>:</span><br><span class="line">    _agent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 构建提示词</span></span><br><span class="line">        prompt = <span class="string">&quot;你是AI助手，你应当回答用户的问题，根据提供的资料、历史信息、文件内容进行回复。&quot;</span></span><br><span class="line"></span><br><span class="line">        agent = create_agent(</span><br><span class="line">            model=init_model(),</span><br><span class="line">            tools=[rag_tool],</span><br><span class="line">            system_prompt=prompt,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        RagAgent._agent = agent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 智能体调用函数（流式）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, user_input: <span class="built_in">str</span>, db_id: <span class="built_in">int</span>, conversation_history=<span class="literal">None</span>, has_user_file: <span class="built_in">bool</span>=<span class="literal">False</span>, user_file_content: <span class="built_in">str</span>=<span class="literal">None</span>, token_recorder: TokenRecorder = <span class="literal">None</span>,</span>):</span><br><span class="line">        <span class="keyword">if</span> user_input == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;未输入有效信息&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> RagAgent._agent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.__init__()</span><br><span class="line"></span><br><span class="line">        messages = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> conversation_history:</span><br><span class="line">            recent_history = conversation_history[-<span class="number">40</span>:] <span class="keyword">if</span> <span class="built_in">len</span>(conversation_history) &gt; <span class="number">40</span> <span class="keyword">else</span> conversation_history</span><br><span class="line">            messages.extend(recent_history)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将openai格式对话转为langchain格式</span></span><br><span class="line">        langchain_messages = convert_openai_messages(messages)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> db_id:</span><br><span class="line">            langchain_messages.append(SystemMessage(content=<span class="string">f&quot;当前查询应使用知识库 ID: <span class="subst">&#123;db_id&#125;</span>&quot;</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Log.warning(<span class="string">&quot;未传入数据库id，默认使用id为1的数据库&quot;</span>)</span><br><span class="line">            langchain_messages.append(SystemMessage(content=<span class="string">f&quot;当前查询应使用知识库 ID: 1&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若有文件添加文件信息</span></span><br><span class="line">        <span class="keyword">if</span> has_user_file <span class="keyword">and</span> user_file_content:</span><br><span class="line">            langchain_messages.append(SystemMessage(content=<span class="string">f&quot;这是用户上传的文件内容：<span class="subst">&#123;user_file_content&#125;</span>&quot;</span>))</span><br><span class="line"></span><br><span class="line">        langchain_messages.append(HumanMessage(content=user_input))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> model, chunk <span class="keyword">in</span> RagAgent._agent.stream(&#123;<span class="string">&quot;messages&quot;</span>: langchain_messages&#125;, stream_mode=[<span class="string">&quot;custom&quot;</span>, <span class="string">&quot;updates&quot;</span>]):</span><br><span class="line">            <span class="keyword">if</span> model == <span class="string">&#x27;updates&#x27;</span>:</span><br><span class="line">                (step, data), = chunk.items()</span><br><span class="line">                <span class="keyword">if</span> step == <span class="string">&#x27;model&#x27;</span>:</span><br><span class="line">                    content = data[<span class="string">&#x27;messages&#x27;</span>][-<span class="number">1</span>].content</span><br><span class="line">                    <span class="keyword">yield</span> content</span><br><span class="line">                <span class="keyword">elif</span> step == <span class="string">&#x27;tools&#x27;</span>:</span><br><span class="line">                    <span class="keyword">yield</span> <span class="string">f&quot;正在调用工具&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> model == <span class="string">&#x27;custom&#x27;</span>:</span><br><span class="line">                <span class="keyword">yield</span> <span class="built_in">set</span>(chunk[<span class="string">&#x27;links&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>然后我将LangChain换成了LangGraph，解决了stream输出的问题，现在能够逐token式的输出了，但仍然无法输出思考内容。后面发现langchain的ChatOpenAI接口创建的客户端，在返回结果时会丢弃掉reasoning_content。（似乎根据官方说法，他们认为这是冗余的……）</p><p><img src="/2025/07/15/hello-world/%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/2.png"></p><p>然后在langchain_community里找到了一个ChatDeepSeek接口。<img src="/2025/07/15/hello-world/%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/3.png">好消息是返回结果里有reasoning_content，在additional_kwargs里，坏消息是思考内容无法回传。也就是说无法像DeepSeek的api官方文档里要求的一样，输入内容要传回<strong>工具</strong>、<strong>问题</strong>、<strong>思维链</strong>、<strong>工具调用</strong>、<strong>调用结果</strong>，具体表现为在回传时会报错，即回传的内容缺少思维链部分（即缺少reasoning_content字段)。</p><p>deepseek思考模式下进行工具调用的 API 请求示意图如下：</p><p><img src="/2025/07/15/hello-world/%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/4.png"></p><p>一开始以为只是回传的AIMessage缺少reasoning_content字段，结果不管是直接加到和content的同级，还是加到additional_kwargs里都会报错。后来我甚至尝试自定义AIMessage，但是也还是行不通。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeepSeekAIMessage</span>(<span class="title class_ inherited__">AIMessage</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义AIMessage，支持DeepSeek模型的思考内容&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    reasoning_content: <span class="type">Optional</span>[<span class="built_in">str</span>] = Field(</span><br><span class="line">        default=<span class="literal">None</span>,</span><br><span class="line">        description=<span class="string">&quot;DeepSeek模型的推理思考内容&quot;</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    …………</span><br></pre></td></tr></table></figure><p>于是我直接打断点调试，到了LangGraph模块的内部，发现内部确实无法解析reasoning_content字段，所以只能抛弃LangGraph框架了。最后拿OpenAI SDK和Tool Calls做出来了。但是发现写出来的东西，非流式的正常运行，流式的总是报错说index不对，似乎是缺了一条AIMessage。</p><p>非流式版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让大模型调用工具</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rag_func_call</span>(<span class="params">input_messages: <span class="built_in">list</span>, conversation_history: <span class="built_in">list</span>=<span class="literal">None</span>, token_recorder: TokenRecorder = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 构建对话信息</span></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        response = client.chat.completions.create(</span><br><span class="line">            <span class="comment"># model=&#x27;deepseek-chat&#x27;,</span></span><br><span class="line">            model=<span class="string">&#x27;deepseek-reasoner&#x27;</span>,</span><br><span class="line">            messages=messages,</span><br><span class="line">            tools=tools,</span><br><span class="line">            extra_body=&#123;<span class="string">&quot;thinking&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;enabled&quot;</span>&#125;&#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        messages.append(response.choices[<span class="number">0</span>].message)</span><br><span class="line">        reasoning_content = response.choices[<span class="number">0</span>].message.reasoning_content</span><br><span class="line">        content = response.choices[<span class="number">0</span>].message.content</span><br><span class="line">        tool_calls = response.choices[<span class="number">0</span>].message.tool_calls</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 存入历史，不带思维链</span></span><br><span class="line">        ……</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录ai返回的信息</span></span><br><span class="line">        ai_message = &#123;</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: content,</span><br><span class="line">            <span class="string">&quot;reasoning_content&quot;</span>: reasoning_content,</span><br><span class="line">            <span class="string">&quot;tool_calls&quot;</span>: tool_calls,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> ai_message</span><br><span class="line">        <span class="comment"># 无工具调用则返回</span></span><br><span class="line">        <span class="keyword">if</span> tool_calls <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            conversation_history.append(ai_message)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> tool <span class="keyword">in</span> tool_calls:</span><br><span class="line">                tool_function = TOOL_CALL_MAP[tool.function.name]</span><br><span class="line">                tool_result, links = tool_function(**json.loads(tool.function.arguments))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 返回工具调用信息</span></span><br><span class="line">……</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>流式版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让大模型调用工具</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rag_func_call_stream</span>(<span class="params">messages: <span class="built_in">list</span>, conversation_history: <span class="built_in">list</span>, token_recorder: TokenRecorder = <span class="literal">None</span>, return_toolcall_reasoning: <span class="built_in">bool</span> = <span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment"># 缓存流式处理结果</span></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 工具调用结束且得到答案则退出</span></span><br><span class="line">        ……</span><br><span class="line"></span><br><span class="line">        response = client.chat.completions.create(</span><br><span class="line">            <span class="comment"># model=&#x27;deepseek-chat&#x27;,</span></span><br><span class="line">            model=<span class="string">&#x27;deepseek-reasoner&#x27;</span>,</span><br><span class="line">            messages=messages,</span><br><span class="line">            tools=tools,</span><br><span class="line">            stream=<span class="literal">True</span>,</span><br><span class="line">            extra_body=&#123;<span class="string">&quot;thinking&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;enabled&quot;</span>&#125;&#125;</span><br><span class="line">        )</span><br><span class="line">        Log.info(messages)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理每一个delta</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> response:</span><br><span class="line">            delta = chunk.choices[<span class="number">0</span>].delta</span><br><span class="line">            finish_reason = chunk.choices[<span class="number">0</span>].finish_reason</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果有结束原因尝试获取token消耗</span></span><br><span class="line">            ……</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断当前 delta 类型</span></span><br><span class="line">            ……</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查类型变化并生成特殊标记</span></span><br><span class="line">            <span class="keyword">if</span> previous_type != new_type:</span><br><span class="line">                ……</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> previous_type == <span class="string">&#x27;tool_calls&#x27;</span>:</span><br><span class="line">                    <span class="keyword">for</span> tool <span class="keyword">in</span> buffer[<span class="string">&quot;tool_calls&quot;</span>]:</span><br><span class="line">                        tool_function = TOOL_CALL_MAP[tool[<span class="string">&quot;name&quot;</span>]]</span><br><span class="line">                        tool_result, links = tool_function(**json.loads(tool[<span class="string">&quot;arguments&quot;</span>]))</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 返回工具调用信息</span></span><br><span class="line">                        ……</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 工具参数置空</span></span><br><span class="line">                        tool[<span class="string">&#x27;arguments&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">yield</span> <span class="string">f&quot;__REFERENCE_LINK__:<span class="subst">&#123;links&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 工具调用结束标记</span></span><br><span class="line">                    tool_call_finish = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新 previous_type</span></span><br><span class="line">                previous_type = new_type</span><br><span class="line"></span><br><span class="line">            ……</span><br></pre></td></tr></table></figure><p>通过断点调试，对比两种方式回传数据差别。最终发现非流式不报错的原因就在这一行代码<code>messages.append(response.choices[0].message)</code>。调试时发现非流式的message中，在工具调用结束后比流式的多了一个<strong>ChatCompletionMessage</strong>类型的数据。</p><p>主要原因如下，非流式返回的消息为<strong>ChatCompletionMessage</strong>，在需要工具调用时会传这么一条<strong>ChatCompletionMessage</strong>，内容有工具调用的思考内容和工具调用id和参数，这条信息是需要保存到messages中然后回传的。而流式输出之所以会报错是因为其返回的消息类型为**<code>ChatCompletionChunk</code><strong>，而需要回传的是</strong>ChatCompletionMessage**，所以回传时会出错。于是只能手动缓存思考内容和工具调用，然后手动封装<strong>ChatCompletionMessage</strong>回传，于是问题这么解决了，这样思考内容和对话都能主token地输出了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动封装ChatCompletionMessage</span></span><br><span class="line">tool_call_completion = ChatCompletionMessage(</span><br><span class="line">    content=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    role=<span class="string">&#x27;assistant&#x27;</span>,</span><br><span class="line">    reasoning_content=buffer[<span class="string">&#x27;reasoning&#x27;</span>],</span><br><span class="line">    tool_calls=[</span><br><span class="line">        ChatCompletionMessageToolCall(</span><br><span class="line">            <span class="built_in">id</span>=tool[<span class="string">&quot;tid&quot;</span>],</span><br><span class="line">            function=Function(</span><br><span class="line">                arguments=tool[<span class="string">&quot;arguments&quot;</span>],</span><br><span class="line">                name=tool[<span class="string">&quot;name&quot;</span>],</span><br><span class="line">            ),</span><br><span class="line">            <span class="built_in">type</span>=<span class="string">&#x27;function&#x27;</span>,</span><br><span class="line">            index=tool[<span class="string">&#x27;index&#x27;</span>]</span><br><span class="line">        )</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">messages.append(tool_call_completion)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>非流式返回的消息为<strong>ChatCompletionMessage</strong>，流式输出其返回的消息类型为**<code>ChatCompletionChunk</code><strong>。在思考模式下Tool Calls，需要工具调用的思考内容和工具调用id和参数，并且以</strong>ChatCompletionMessage**。如果是非流式直接将ai返回内容加入messages即可，而六十需要自己手动封装。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win系统下一个文件句柄问题的解决</title>
      <link href="/2025/12/15/win%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2025/12/15/win%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上周晚上，同事写数据库全量更新时发现，在激活新库的时候，总是会报无法获取写权限错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(backup_db_path):</span><br><span class="line">os.rename(backup_db_path, db_path)</span><br></pre></td></tr></table></figure><p>错误代码大致如下：<span class="hide-inline"><button type="button" class="hide-button" style="background-color: #335;color: #335">click here</button><span class="hide-content">（这里没有截图，只能手动还原一下了）</span></span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermissionError: [WinError 5] Access is denied: </span><br></pre></td></tr></table></figure><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>同事的逻辑如下：</p><p>处理好文件后，将其数据存入新建的数据库。等处理好所有数据后，先将原来的数据库保存为备份，再使用激活新库、删除旧库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[开始] --&gt; B[处理文件]</span><br><span class="line">    B --&gt; C[将处理后的数据存入新建数据库]</span><br><span class="line">    C --&gt; D&#123;所有数据处理完成?&#125;</span><br><span class="line">    D -- 是 --&gt; E[将原数据库保存为备份]</span><br><span class="line">    D -- 否 --&gt; B</span><br><span class="line">    E --&gt; F[激活新建数据库]</span><br><span class="line">    F --&gt; G&#123;激活成功?&#125;</span><br><span class="line">    G -- 是 --&gt; H[删除旧数据库]</span><br><span class="line">    G -- 否 --&gt; I[回滚: 使用备份的旧库]</span><br><span class="line">    H --&gt; J[结束]</span><br><span class="line">    I --&gt; J</span><br></pre></td></tr></table></figure><p>因为chromaDB的数据库是持久化在磁盘上的，将原来的数据库视为备份以及激活数据库操作等都是通过重命名数据库文件完成的。<br>查阅资料和排查后，初步认定是操作系统在数据处理过程中获取了文件夹句柄，却没有在操作结束后释放。通过资源管理器可以看到，对更改命名的新库文件夹，在完成数据处理操作后仍有两个句柄未释放，且这两个句柄来自同一进程（拥有相同的PID），即当前全量更新的进程。</p><span class="hide-inline"><button type="button" class="hide-button" style="background-color: #335;color: #335">click here</button><span class="hide-content">（在windows上可以通过资源管理器查看句柄情况，搜索句柄貌似只能搜文件而不是文件夹）</span></span><p><img src="/2025/07/15/hello-world/%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/1.png"><br>而后通过断点调试与单步执行等方式排查发现，chromaDB的createPersistentClient操作会一次获取两个句柄。这两个句柄归属于我们所运行的服务本身，所以句柄只会在程序结束后释放。故后续激活新数据库时，会因为句柄未得到释放而操作失败。</p><p>尝试调用close方法手动关闭客户端，但是发现chroma客户端没有close方法。</p><p><img src="/2025/07/15/hello-world/%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/2.png"></p><p>在代码中尝试手动<code>del</code>掉<code>chromaDB</code>的<code>createPersistentClient</code>的引用，然后立即手动使用<code>gc.collect()</code>回收内存，让其释放句柄。</p><p>但该方法并未起效，即使<code>sleep()</code>等待一段时间也不可行。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将原本的数据库全量更新操作分为两个原子操作：数据处理与数据库激活。将数据处理操作放入子进程中，当这个子进程结束时，因为数据处理过程中获得的句柄就会自然释放掉，从而使得可以进行数据库激活操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">full_database_update</span>(<span class="params">source_dir: <span class="built_in">str</span>, db_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    执行数据库全量更新的主流程。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    该函数将全量更新拆分为两个阶段：</span></span><br><span class="line"><span class="string">    1. 启动子进程执行数据处理，生成新的数据库文件（临时路径）；</span></span><br><span class="line"><span class="string">    2. 等待子进程结束后，执行原子性的数据库激活操作。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    若任一阶段失败，将尝试回滚并返回 False；成功则返回 True。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_data_in_subprocess</span>(<span class="params">source_dir: <span class="built_in">str</span>, new_db_path: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在独立子进程中执行数据处理逻辑，生成全新的数据库文件。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    此函数通常由子进程调用（例如通过 subprocess），负责：</span></span><br><span class="line"><span class="string">    - 解析 source_dir 中的所有源文件；</span></span><br><span class="line"><span class="string">    - 创建 new_db_path 指定的新数据库；</span></span><br><span class="line"><span class="string">    - 建表、写入全量处理后的数据；</span></span><br><span class="line"><span class="string">    - 正常关闭数据库连接后退出。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    注意：该函数不操作原数据库，仅输出新库文件。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">activate_new_database</span>(<span class="params">current_db_path: <span class="built_in">str</span>, new_db_path: <span class="built_in">str</span>, backup_db_path: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    执行数据库激活操作，完成新旧数据库的原子切换。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    操作步骤：</span></span><br><span class="line"><span class="string">    1. 若当前数据库存在，将其备份到 backup_db_path；</span></span><br><span class="line"><span class="string">    2. 将 new_db_path 原子地重命名为 current_db_path；</span></span><br><span class="line"><span class="string">    3. 若激活失败，尝试从 backup_db_path 恢复原库。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    该函数假设 new_db_path 已由子进程完整写入且句柄已释放。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>将将数据处理操作放入子进程中后，子进程中的日志操作就出现了问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermissionError: [WinError 32] 另一个程序正在使用此文件，进程无法访问。:</span><br></pre></td></tr></table></figure><p>当子进程尝试访问日志文件时，会因为日志文件正在被主进程访问而导致金城江的并发问题，这种并发就不是之前用<code>loguru</code>的设置<code>enqueue=True</code>就可以解决的了。要想解决这种问题，可能需要为系统的各个进程单独设置日志系统。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于python日志系统的实现</title>
      <link href="/2025/12/08/%E5%85%B3%E4%BA%8Epython%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/12/08/%E5%85%B3%E4%BA%8Epython%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>上周，公司要我给系统添加一个日志系统，当时感觉这个比较简单，于是使用<code>logging</code>实现没有用<code>loguru</code>，由于马上就要交付项目所以写的比较急。结果在日志轮转时报错了。在原本的日志系统中我使用的是<code>TimedRotatingFileHandler</code>。</p><p>错误如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermissionError: [WinError 32] 另一个程序正在使用此文件，进程无法访问。: <span class="string">&#x27;E:\\…………\\loggings\\app.log.1&#x27;</span></span><br></pre></td></tr></table></figure><p>这个错误发生在 <code>TimedRotatingFileHandler</code> 的 <code>doRollover()</code> 方法中，当它尝试重命名日志文件（如 <code>app.log</code> → <code>app.log.1</code>）时，发现原文件被其他进程或线程“锁定”了。</p><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><p>首先，查看doRollver()方法，将其代码简化后如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">doRollover</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.stream:</span><br><span class="line">        <span class="variable language_">self</span>.stream.close()</span><br><span class="line">        <span class="variable language_">self</span>.stream = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># get the time that this sequence started at and make it a TimeTuple</span></span><br><span class="line">    dfn = <span class="variable language_">self</span>.baseFilename + <span class="string">&quot;.&quot;</span> + time.strftime(<span class="variable language_">self</span>.suffix, timeTuple)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(dfn):</span><br><span class="line">        os.remove(dfn)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="variable language_">self</span>.baseFilename):</span><br><span class="line">        os.rename(<span class="variable language_">self</span>.baseFilename, dfn)</span><br><span class="line">    <span class="variable language_">self</span>.rolloverAt = newRolloverAt</span><br></pre></td></tr></table></figure><p>注意到<strong>在执行滚动（rotate）时，需要调用 <code>os.rename()</code> 来重命名旧日志文件，但 Windows 系统不允许对正在被打开&#x2F;写入的文件进行重命名。</strong></p><p>我们所使用的python服务器是fastapi，安装了WatchFiles并启用了reload。一开始怀疑是，中途修改代码而没有使用<code>atexit.register(Log.close)</code>导致服务重启后旧句柄未释放。</p><p>但后来发现WatchFiles的重启似乎不算正常结束进程，无法触发<code>atexit.register(Log.close)</code>，这时我又想到了fastapi本身就有一定的异步特性。不过这方面因为时间原因并没有深究。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>导入loguru使用loguru库重写了日志系统，设置<code>enqueue=True</code>，这种设置能够使得日志写入操作变得异步安全，但缺点是可能会导致实时性降低。</p><p>根据查阅到的资料，其内部似乎是一种MQ的实现。即日志消息被<strong>推入线程安全队列</strong>，由 <strong>独立的后台线程</strong> 负责消费队列并写入。成功推入队列则返回写入成功，而<strong>独立的后台线程</strong>以较恒定的速度消费队列。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code test</title>
      <link href="/2025/07/15/code-test/"/>
      <url>/2025/07/15/code-test/</url>
      
        <content type="html"><![CDATA[<p>这是一个简单python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  ANN</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> neurolab <span class="keyword">as</span> nl</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 50 个二维样本，分为 2 类</span></span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">50</span>, centers=<span class="number">2</span>, cluster_std=<span class="number">5</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化生成的数据</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, cmap=<span class="string">&#x27;coolwarm&#x27;</span>, edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Generated Input Data&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Dimension 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Dimension 2&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整标签形状以适配 neurolab</span></span><br><span class="line">y = y.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">data = X</span><br><span class="line">labels = y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制输入数据散点图</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Dimension 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Dimension 2&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输入维度范围和输出数量</span></span><br><span class="line">dim1 = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">dim2 = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">num_output = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建感知机神经网络</span></span><br><span class="line">perceptron = nl.net.newp([dim1, dim2], num_output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">error_progress = perceptron.train(data, labels, epochs=<span class="number">80</span>, show=<span class="number">20</span>, lr=<span class="number">0.03</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练误差曲线</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(error_progress)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Training error&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training error progress&#x27;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#  ANN</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> neurolab <span class="keyword">as</span> nl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">text = np.loadtxt(<span class="string">&#x27;data_simple_neural.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取输入特征和标签</span></span><br><span class="line">data = text[:, <span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">labels = text[:, <span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制原始数据散点图</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Dimension 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Dimension 2&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取输入维度范围</span></span><br><span class="line">dim1_min, dim1_max = data[:, <span class="number">0</span>].<span class="built_in">min</span>(), data[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">dim2_min, dim2_max = data[:, <span class="number">1</span>].<span class="built_in">min</span>(), data[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定输出维度数量</span></span><br><span class="line">num_output = labels.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">dim1=[dim1_min, dim1_max]</span><br><span class="line">dim2=[dim2_min, dim2_max]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建单层感知机网络</span></span><br><span class="line">nn = nl.net.newp([dim1,  dim2], num_output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练网络</span></span><br><span class="line">error_progress = nn.train(data, labels, epochs=<span class="number">100</span>, show=<span class="number">20</span>, lr=<span class="number">0.03</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练误差曲线</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(error_progress)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Training error&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training error progress&#x27;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nTest results:&#x27;</span>)</span><br><span class="line">data_test = [[<span class="number">0.5</span>, <span class="number">3.2</span>],  [<span class="number">2.9</span>, <span class="number">0.1</span>], [<span class="number">1.1</span>, <span class="number">1.9</span>], [<span class="number">2.8</span>, <span class="number">2.8</span>]]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data_test:</span><br><span class="line">    <span class="built_in">print</span>(item, <span class="string">&#x27;-&gt;&#x27;</span>, nn.sim([item])[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#  ANN</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> neurolab <span class="keyword">as</span> nl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据范围和数量</span></span><br><span class="line">min_val = -<span class="number">20</span></span><br><span class="line">max_val = <span class="number">20</span></span><br><span class="line">num_points = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成输入数据并创建目标输出</span></span><br><span class="line">x = np.linspace(min_val, max_val, num_points)</span><br><span class="line">y = <span class="number">2</span> * np.square(x) + <span class="number">7</span></span><br><span class="line">y /= np.linalg.norm(y)  <span class="comment"># 归一化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备训练数据</span></span><br><span class="line">data = x.reshape(num_points, <span class="number">1</span>)</span><br><span class="line">labels = y.reshape(num_points, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制输入数据</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(data, labels)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Dimension 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Dimension 2&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建神经网络</span></span><br><span class="line">nn = nl.net.newff([[min_val, max_val]], [<span class="number">10</span>, <span class="number">6</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置训练算法为梯度下降</span></span><br><span class="line">nn.trainf = nl.train.train_gd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练网络</span></span><br><span class="line">error_progress = nn.train(data, labels, epochs=<span class="number">1600</span>, show=<span class="number">100</span>, goal=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行预测</span></span><br><span class="line">output = nn.sim(data)</span><br><span class="line">y_pred = output.reshape(num_points)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练误差进度</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(error_progress)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training error progress&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建更密集的输入数据用于可视化预测结果</span></span><br><span class="line">x_dense = np.linspace(min_val, max_val, num_points * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测密集数据</span></span><br><span class="line">y_dense_pred = nn.sim(x_dense.reshape(x_dense.size, <span class="number">1</span>)).reshape(x_dense.size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制实际 vs 预测结果</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x_dense, y_dense_pred, <span class="string">&#x27;-&#x27;</span>, x, y, <span class="string">&#x27;.&#x27;</span>, x, y_pred, <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Actual vs predicted&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt. show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># RNN</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> neurolab <span class="keyword">as</span> nl</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">num_points</span>):</span><br><span class="line">    wave_1 = <span class="number">0.49</span> * np.sin(np.arange(<span class="number">0</span>, num_points))</span><br><span class="line">    wave_2 = <span class="number">3.62</span> * np.sin(np.arange(<span class="number">0</span>, num_points))</span><br><span class="line">    wave_3 = <span class="number">1.2</span> * np.sin(np.arange(<span class="number">0</span>, num_points))</span><br><span class="line">    wave_4 = <span class="number">4.6</span> * np.sin(np.arange(<span class="number">0</span>, num_points))</span><br><span class="line"></span><br><span class="line">    amp_1 = np.ones(num_points)</span><br><span class="line">    amp_2 = <span class="number">2</span> + np.zeros(num_points)</span><br><span class="line">    amp_3 = <span class="number">3.1</span> * np.ones(num_points)</span><br><span class="line">    amp_4 = <span class="number">0.9</span> + np.zeros(num_points)</span><br><span class="line"></span><br><span class="line">    wave = np.array([wave_1, wave_2, wave_3, wave_4]).reshape(num_points * <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">    amp = np.array([amp_1, amp_2, amp_3, amp_4]).reshape(num_points * <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wave, amp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_output</span>(<span class="params">nn, num_points_test</span>):</span><br><span class="line">    wave, amp = get_data(num_points_test)</span><br><span class="line">    output = nn.sim(wave)</span><br><span class="line">    plt.plot(amp.reshape(num_points_test * <span class="number">4</span>))</span><br><span class="line">    plt.plot(output.reshape(num_points_test * <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_points = <span class="number">50</span></span><br><span class="line">    wave, amp = get_data(num_points)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 newelm 网络</span></span><br><span class="line">    nn = nl.net.newelm([[-<span class="number">3</span>, <span class="number">3</span>]] , [<span class="number">9</span>, <span class="number">1</span>], [nl.trans.TanSig(), nl.trans.PureLin()])</span><br><span class="line">    nn.layers[<span class="number">0</span>].initf = nl.init.InitRand([-<span class="number">0.1</span>, <span class="number">0.1</span>], <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    nn.layers[<span class="number">1</span>].initf = nl.init.InitRand([-<span class="number">0.1</span>, <span class="number">0.1</span>], <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    nn.init()</span><br><span class="line"></span><br><span class="line">    error_progress = nn.train(wave, amp, epochs=<span class="number">1200</span>, show=<span class="number">100</span>, goal=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">    output = nn.sim(wave)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">221</span>)</span><br><span class="line">    plt.plot(error_progress)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Number of Epochs&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.plot(amp.reshape(num_points * <span class="number">4</span>))</span><br><span class="line">    plt.plot(output.reshape(num_points * <span class="number">4</span>))</span><br><span class="line">    plt.legend([<span class="string">&#x27;Original&#x27;</span>, <span class="string">&#x27;Predicted&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">223</span>)</span><br><span class="line">    visualize_output(nn, <span class="number">83</span>)</span><br><span class="line">    plt.xlim([<span class="number">0</span>, <span class="number">300</span>])</span><br><span class="line">    plt.subplot(<span class="number">224</span>)</span><br><span class="line">    visualize_output(nn, <span class="number">48</span>)</span><br><span class="line">    plt.xlim([<span class="number">0</span>, <span class="number">300</span>])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># LSTM</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> neurolab <span class="keyword">as</span> nl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置参数</span></span><br><span class="line">input_file = <span class="string">&#x27;letter.data&#x27;</span></span><br><span class="line">num_datapoints = <span class="number">40</span></span><br><span class="line">orig_labels = <span class="string">&#x27;encode&#x27;</span>  <span class="comment"># 注意：这里保留原始字符串，不去除空格</span></span><br><span class="line">num_orig_labels = <span class="built_in">len</span>(orig_labels)</span><br><span class="line"></span><br><span class="line">num_train = <span class="built_in">int</span>(<span class="number">0.9</span> * num_datapoints)</span><br><span class="line">num_test = num_datapoints - num_train</span><br><span class="line">start = <span class="number">6</span></span><br><span class="line">end = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据容器</span></span><br><span class="line">data = []</span><br><span class="line">labels = []</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            list_vals = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)  <span class="comment"># 假设分隔符是 &#x27;&lt;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> list_vals[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> orig_labels:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            label = np.zeros((num_orig_labels, <span class="number">1</span>))</span><br><span class="line">            label[orig_labels.index(list_vals[<span class="number">1</span>])] = <span class="number">1</span></span><br><span class="line">            labels.append(label)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 提取特征向量</span></span><br><span class="line">            cur_char = np.array([<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> list_vals[start:end]])</span><br><span class="line">            data.append(cur_char)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) &gt;= num_datapoints:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转换为 NumPy 数组</span></span><br><span class="line">    data = np.asfarray(data)</span><br><span class="line">    labels = np.array(labels).reshape(num_datapoints, num_orig_labels)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 神经网络配置</span></span><br><span class="line">    num_dims = <span class="built_in">len</span>(data[<span class="number">0</span>])</span><br><span class="line">    nn = nl.net.newff([[<span class="number">0</span>, <span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data[<span class="number">0</span>]))], [<span class="number">128</span>, <span class="number">16</span>, num_orig_labels])</span><br><span class="line">    nn.trainf = nl.train.train_gd</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    error_progress = nn.train(data[:num_train, :], labels[:num_train, :],</span><br><span class="line">                              epochs=<span class="number">5000</span>, show=<span class="number">500</span>, goal=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试模型</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTesting on unknown data:&#x27;</span>)</span><br><span class="line">    predicted_test = nn.sim(data[num_train:, :])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_test):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\nOriginal:&#x27;</span>, orig_labels[np.argmax(labels[i])])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Predicted:&#x27;</span>, orig_labels[np.argmax(predicted_test[i])])</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: File &#x27;<span class="subst">&#123;input_file&#125;</span>&#x27; not found.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;An error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/07/15/hello-world/"/>
      <url>/2025/07/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
