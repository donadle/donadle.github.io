<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DeepSeek思考模式下的工具调用与流式输出</title>
      <link href="/2025/12/19/DeepSeek%E6%80%9D%E8%80%83%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/"/>
      <url>/2025/12/19/DeepSeek%E6%80%9D%E8%80%83%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="DeepSeek思考模式下的工具调用与流式输出"><a href="#DeepSeek思考模式下的工具调用与流式输出" class="headerlink" title="DeepSeek思考模式下的工具调用与流式输出"></a>DeepSeek思考模式下的工具调用与流式输出</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，也就是12月1日，DeepSeek的api更新到了V3.2，增加了思考模式下调用工具的能力，正好项目也有把原来的RAG换成Agentic RAG的意向。在写完这个功能后，找机会记录一下其中遇到的一些情况。</p><p><img src="/2025/07/15/hello-world/%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/1.png"></p><h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>首先我用DeepSeek和langchain搓了一个简易的智能体框架，但是有如下缺点：</p><ul><li>只能使用stream方法只能分步输出，即完成一步操作，将结果一次完整输出。不符合预想的流式输出格式。</li><li>没有输出思考内容。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RagAgent</span>:</span><br><span class="line">    _agent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 构建提示词</span></span><br><span class="line">        prompt = <span class="string">&quot;你是AI助手，你应当回答用户的问题，根据提供的资料、历史信息、文件内容进行回复。&quot;</span></span><br><span class="line"></span><br><span class="line">        agent = create_agent(</span><br><span class="line">            model=init_model(),</span><br><span class="line">            tools=[rag_tool],</span><br><span class="line">            system_prompt=prompt,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        RagAgent._agent = agent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 智能体调用函数（流式）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, user_input: <span class="built_in">str</span>, db_id: <span class="built_in">int</span>, conversation_history=<span class="literal">None</span>, has_user_file: <span class="built_in">bool</span>=<span class="literal">False</span>, user_file_content: <span class="built_in">str</span>=<span class="literal">None</span>, token_recorder: TokenRecorder = <span class="literal">None</span>,</span>):</span><br><span class="line">        <span class="keyword">if</span> user_input == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;未输入有效信息&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> RagAgent._agent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.__init__()</span><br><span class="line"></span><br><span class="line">        messages = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> conversation_history:</span><br><span class="line">            recent_history = conversation_history[-<span class="number">40</span>:] <span class="keyword">if</span> <span class="built_in">len</span>(conversation_history) &gt; <span class="number">40</span> <span class="keyword">else</span> conversation_history</span><br><span class="line">            messages.extend(recent_history)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将openai格式对话转为langchain格式</span></span><br><span class="line">        langchain_messages = convert_openai_messages(messages)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> db_id:</span><br><span class="line">            langchain_messages.append(SystemMessage(content=<span class="string">f&quot;当前查询应使用知识库 ID: <span class="subst">&#123;db_id&#125;</span>&quot;</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Log.warning(<span class="string">&quot;未传入数据库id，默认使用id为1的数据库&quot;</span>)</span><br><span class="line">            langchain_messages.append(SystemMessage(content=<span class="string">f&quot;当前查询应使用知识库 ID: 1&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若有文件添加文件信息</span></span><br><span class="line">        <span class="keyword">if</span> has_user_file <span class="keyword">and</span> user_file_content:</span><br><span class="line">            langchain_messages.append(SystemMessage(content=<span class="string">f&quot;这是用户上传的文件内容：<span class="subst">&#123;user_file_content&#125;</span>&quot;</span>))</span><br><span class="line"></span><br><span class="line">        langchain_messages.append(HumanMessage(content=user_input))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> model, chunk <span class="keyword">in</span> RagAgent._agent.stream(&#123;<span class="string">&quot;messages&quot;</span>: langchain_messages&#125;, stream_mode=[<span class="string">&quot;custom&quot;</span>, <span class="string">&quot;updates&quot;</span>]):</span><br><span class="line">            <span class="keyword">if</span> model == <span class="string">&#x27;updates&#x27;</span>:</span><br><span class="line">                (step, data), = chunk.items()</span><br><span class="line">                <span class="keyword">if</span> step == <span class="string">&#x27;model&#x27;</span>:</span><br><span class="line">                    content = data[<span class="string">&#x27;messages&#x27;</span>][-<span class="number">1</span>].content</span><br><span class="line">                    <span class="keyword">yield</span> content</span><br><span class="line">                <span class="keyword">elif</span> step == <span class="string">&#x27;tools&#x27;</span>:</span><br><span class="line">                    <span class="keyword">yield</span> <span class="string">f&quot;正在调用工具&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> model == <span class="string">&#x27;custom&#x27;</span>:</span><br><span class="line">                <span class="keyword">yield</span> <span class="built_in">set</span>(chunk[<span class="string">&#x27;links&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>然后我将LangChain换成了LangGraph，解决了stream输出的问题，现在能够逐token式的输出了，但仍然无法输出思考内容。后面发现langchain的ChatOpenAI接口创建的客户端，在返回结果时会丢弃掉reasoning_content。（似乎根据官方说法，他们认为这是冗余的……）</p><p><img src="/2025/07/15/hello-world/%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/2.png"></p><p>然后在langchain_community里找到了一个ChatDeepSeek接口。<img src="/2025/07/15/hello-world/%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/3.png">好消息是返回结果里有reasoning_content，在additional_kwargs里，坏消息是思考内容无法回传。也就是说无法像DeepSeek的api官方文档里要求的一样，输入内容要传回<strong>工具</strong>、<strong>问题</strong>、<strong>思维链</strong>、<strong>工具调用</strong>、<strong>调用结果</strong>，具体表现为在回传时会报错，即回传的内容缺少思维链部分（即缺少reasoning_content字段)。</p><p>deepseek思考模式下进行工具调用的 API 请求示意图如下：</p><p><img src="/2025/07/15/hello-world/%E4%B8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/4.png"></p><p>一开始以为只是回传的AIMessage缺少reasoning_content字段，结果不管是直接加到和content的同级，还是加到additional_kwargs里都会报错。后来我甚至尝试自定义AIMessage，但是也还是行不通。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeepSeekAIMessage</span>(<span class="title class_ inherited__">AIMessage</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义AIMessage，支持DeepSeek模型的思考内容&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    reasoning_content: <span class="type">Optional</span>[<span class="built_in">str</span>] = Field(</span><br><span class="line">        default=<span class="literal">None</span>,</span><br><span class="line">        description=<span class="string">&quot;DeepSeek模型的推理思考内容&quot;</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    …………</span><br></pre></td></tr></table></figure><p>于是我直接打断点调试，到了LangGraph模块的内部，发现内部确实无法解析reasoning_content字段，所以只能抛弃LangGraph框架了。最后拿OpenAI SDK和Tool Calls做出来了。但是发现写出来的东西，非流式的正常运行，流式的总是报错说index不对，似乎是缺了一条AIMessage。</p><p>非流式版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让大模型调用工具</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rag_func_call</span>(<span class="params">input_messages: <span class="built_in">list</span>, conversation_history: <span class="built_in">list</span>=<span class="literal">None</span>, token_recorder: TokenRecorder = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 构建对话信息</span></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        response = client.chat.completions.create(</span><br><span class="line">            <span class="comment"># model=&#x27;deepseek-chat&#x27;,</span></span><br><span class="line">            model=<span class="string">&#x27;deepseek-reasoner&#x27;</span>,</span><br><span class="line">            messages=messages,</span><br><span class="line">            tools=tools,</span><br><span class="line">            extra_body=&#123;<span class="string">&quot;thinking&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;enabled&quot;</span>&#125;&#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        messages.append(response.choices[<span class="number">0</span>].message)</span><br><span class="line">        reasoning_content = response.choices[<span class="number">0</span>].message.reasoning_content</span><br><span class="line">        content = response.choices[<span class="number">0</span>].message.content</span><br><span class="line">        tool_calls = response.choices[<span class="number">0</span>].message.tool_calls</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 存入历史，不带思维链</span></span><br><span class="line">        ……</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录ai返回的信息</span></span><br><span class="line">        ai_message = &#123;</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: content,</span><br><span class="line">            <span class="string">&quot;reasoning_content&quot;</span>: reasoning_content,</span><br><span class="line">            <span class="string">&quot;tool_calls&quot;</span>: tool_calls,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> ai_message</span><br><span class="line">        <span class="comment"># 无工具调用则返回</span></span><br><span class="line">        <span class="keyword">if</span> tool_calls <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            conversation_history.append(ai_message)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> tool <span class="keyword">in</span> tool_calls:</span><br><span class="line">                tool_function = TOOL_CALL_MAP[tool.function.name]</span><br><span class="line">                tool_result, links = tool_function(**json.loads(tool.function.arguments))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 返回工具调用信息</span></span><br><span class="line">……</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>流式版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让大模型调用工具</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rag_func_call_stream</span>(<span class="params">messages: <span class="built_in">list</span>, conversation_history: <span class="built_in">list</span>, token_recorder: TokenRecorder = <span class="literal">None</span>, return_toolcall_reasoning: <span class="built_in">bool</span> = <span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment"># 缓存流式处理结果</span></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 工具调用结束且得到答案则退出</span></span><br><span class="line">        ……</span><br><span class="line"></span><br><span class="line">        response = client.chat.completions.create(</span><br><span class="line">            <span class="comment"># model=&#x27;deepseek-chat&#x27;,</span></span><br><span class="line">            model=<span class="string">&#x27;deepseek-reasoner&#x27;</span>,</span><br><span class="line">            messages=messages,</span><br><span class="line">            tools=tools,</span><br><span class="line">            stream=<span class="literal">True</span>,</span><br><span class="line">            extra_body=&#123;<span class="string">&quot;thinking&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;enabled&quot;</span>&#125;&#125;</span><br><span class="line">        )</span><br><span class="line">        Log.info(messages)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理每一个delta</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> response:</span><br><span class="line">            delta = chunk.choices[<span class="number">0</span>].delta</span><br><span class="line">            finish_reason = chunk.choices[<span class="number">0</span>].finish_reason</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果有结束原因尝试获取token消耗</span></span><br><span class="line">            ……</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断当前 delta 类型</span></span><br><span class="line">            ……</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查类型变化并生成特殊标记</span></span><br><span class="line">            <span class="keyword">if</span> previous_type != new_type:</span><br><span class="line">                ……</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> previous_type == <span class="string">&#x27;tool_calls&#x27;</span>:</span><br><span class="line">                    <span class="keyword">for</span> tool <span class="keyword">in</span> buffer[<span class="string">&quot;tool_calls&quot;</span>]:</span><br><span class="line">                        tool_function = TOOL_CALL_MAP[tool[<span class="string">&quot;name&quot;</span>]]</span><br><span class="line">                        tool_result, links = tool_function(**json.loads(tool[<span class="string">&quot;arguments&quot;</span>]))</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 返回工具调用信息</span></span><br><span class="line">                        ……</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 工具参数置空</span></span><br><span class="line">                        tool[<span class="string">&#x27;arguments&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">yield</span> <span class="string">f&quot;__REFERENCE_LINK__:<span class="subst">&#123;links&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 工具调用结束标记</span></span><br><span class="line">                    tool_call_finish = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新 previous_type</span></span><br><span class="line">                previous_type = new_type</span><br><span class="line"></span><br><span class="line">            ……</span><br></pre></td></tr></table></figure><p>通过断点调试，对比两种方式回传数据差别。最终发现非流式不报错的原因就在这一行代码<code>messages.append(response.choices[0].message)</code>。调试时发现非流式的message中，在工具调用结束后比流式的多了一个<strong>ChatCompletionMessage</strong>类型的数据。</p><p>主要原因如下，非流式返回的消息为<strong>ChatCompletionMessage</strong>，在需要工具调用时会传这么一条<strong>ChatCompletionMessage</strong>，内容有工具调用的思考内容和工具调用id和参数，这条信息是需要保存到messages中然后回传的。而流式输出之所以会报错是因为其返回的消息类型为**<code>ChatCompletionChunk</code><strong>，而需要回传的是</strong>ChatCompletionMessage**，所以回传时会出错。于是只能手动缓存思考内容和工具调用，然后手动封装<strong>ChatCompletionMessage</strong>回传，于是问题这么解决了，这样思考内容和对话都能主token地输出了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动封装ChatCompletionMessage</span></span><br><span class="line">tool_call_completion = ChatCompletionMessage(</span><br><span class="line">    content=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    role=<span class="string">&#x27;assistant&#x27;</span>,</span><br><span class="line">    reasoning_content=buffer[<span class="string">&#x27;reasoning&#x27;</span>],</span><br><span class="line">    tool_calls=[</span><br><span class="line">        ChatCompletionMessageToolCall(</span><br><span class="line">            <span class="built_in">id</span>=tool[<span class="string">&quot;tid&quot;</span>],</span><br><span class="line">            function=Function(</span><br><span class="line">                arguments=tool[<span class="string">&quot;arguments&quot;</span>],</span><br><span class="line">                name=tool[<span class="string">&quot;name&quot;</span>],</span><br><span class="line">            ),</span><br><span class="line">            <span class="built_in">type</span>=<span class="string">&#x27;function&#x27;</span>,</span><br><span class="line">            index=tool[<span class="string">&#x27;index&#x27;</span>]</span><br><span class="line">        )</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">messages.append(tool_call_completion)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>非流式返回的消息为<strong>ChatCompletionMessage</strong>，流式输出其返回的消息类型为**<code>ChatCompletionChunk</code><strong>。在思考模式下Tool Calls，需要工具调用的思考内容和工具调用id和参数，并且以</strong>ChatCompletionMessage**。如果是非流式直接将ai返回内容加入messages即可，而六十需要自己手动封装。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>win系统下一个文件句柄问题的解决</title>
      <link href="/2025/12/15/win%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2025/12/15/win%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上周晚上，同事写数据库全量更新时发现，在激活新库的时候，总是会报无法获取写权限错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(backup_db_path):</span><br><span class="line">os.rename(backup_db_path, db_path)</span><br></pre></td></tr></table></figure><p>错误代码大致如下：<span class="hide-inline"><button type="button" class="hide-button" style="background-color: #335;color: #335">click here</button><span class="hide-content">（这里没有截图，只能手动还原一下了）</span></span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermissionError: [WinError 5] Access is denied: </span><br></pre></td></tr></table></figure><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>同事的逻辑如下：</p><p>处理好文件后，将其数据存入新建的数据库。等处理好所有数据后，先将原来的数据库保存为备份，再使用激活新库、删除旧库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[开始] --&gt; B[处理文件]</span><br><span class="line">    B --&gt; C[将处理后的数据存入新建数据库]</span><br><span class="line">    C --&gt; D&#123;所有数据处理完成?&#125;</span><br><span class="line">    D -- 是 --&gt; E[将原数据库保存为备份]</span><br><span class="line">    D -- 否 --&gt; B</span><br><span class="line">    E --&gt; F[激活新建数据库]</span><br><span class="line">    F --&gt; G&#123;激活成功?&#125;</span><br><span class="line">    G -- 是 --&gt; H[删除旧数据库]</span><br><span class="line">    G -- 否 --&gt; I[回滚: 使用备份的旧库]</span><br><span class="line">    H --&gt; J[结束]</span><br><span class="line">    I --&gt; J</span><br></pre></td></tr></table></figure><p>因为chromaDB的数据库是持久化在磁盘上的，将原来的数据库视为备份以及激活数据库操作等都是通过重命名数据库文件完成的。<br>查阅资料和排查后，初步认定是操作系统在数据处理过程中获取了文件夹句柄，却没有在操作结束后释放。通过资源管理器可以看到，对更改命名的新库文件夹，在完成数据处理操作后仍有两个句柄未释放，且这两个句柄来自同一进程（拥有相同的PID），即当前全量更新的进程。</p><span class="hide-inline"><button type="button" class="hide-button" style="background-color: #335;color: #335">click here</button><span class="hide-content">（在windows上可以通过资源管理器查看句柄情况，搜索句柄貌似只能搜文件而不是文件夹）</span></span><p><img src="/2025/07/15/hello-world/%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/1.png"><br>而后通过断点调试与单步执行等方式排查发现，chromaDB的createPersistentClient操作会一次获取两个句柄。这两个句柄归属于我们所运行的服务本身，所以句柄只会在程序结束后释放。故后续激活新数据库时，会因为句柄未得到释放而操作失败。</p><p>尝试调用close方法手动关闭客户端，但是发现chroma客户端没有close方法。</p><p><img src="/2025/07/15/hello-world/%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/2.png"></p><p>在代码中尝试手动<code>del</code>掉<code>chromaDB</code>的<code>createPersistentClient</code>的引用，然后立即手动使用<code>gc.collect()</code>回收内存，让其释放句柄。</p><p>但该方法并未起效，即使<code>sleep()</code>等待一段时间也不可行。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将原本的数据库全量更新操作分为两个原子操作：数据处理与数据库激活。将数据处理操作放入子进程中，当这个子进程结束时，因为数据处理过程中获得的句柄就会自然释放掉，从而使得可以进行数据库激活操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">full_database_update</span>(<span class="params">source_dir: <span class="built_in">str</span>, db_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    执行数据库全量更新的主流程。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    该函数将全量更新拆分为两个阶段：</span></span><br><span class="line"><span class="string">    1. 启动子进程执行数据处理，生成新的数据库文件（临时路径）；</span></span><br><span class="line"><span class="string">    2. 等待子进程结束后，执行原子性的数据库激活操作。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    若任一阶段失败，将尝试回滚并返回 False；成功则返回 True。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_data_in_subprocess</span>(<span class="params">source_dir: <span class="built_in">str</span>, new_db_path: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在独立子进程中执行数据处理逻辑，生成全新的数据库文件。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    此函数通常由子进程调用（例如通过 subprocess），负责：</span></span><br><span class="line"><span class="string">    - 解析 source_dir 中的所有源文件；</span></span><br><span class="line"><span class="string">    - 创建 new_db_path 指定的新数据库；</span></span><br><span class="line"><span class="string">    - 建表、写入全量处理后的数据；</span></span><br><span class="line"><span class="string">    - 正常关闭数据库连接后退出。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    注意：该函数不操作原数据库，仅输出新库文件。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">activate_new_database</span>(<span class="params">current_db_path: <span class="built_in">str</span>, new_db_path: <span class="built_in">str</span>, backup_db_path: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    执行数据库激活操作，完成新旧数据库的原子切换。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    操作步骤：</span></span><br><span class="line"><span class="string">    1. 若当前数据库存在，将其备份到 backup_db_path；</span></span><br><span class="line"><span class="string">    2. 将 new_db_path 原子地重命名为 current_db_path；</span></span><br><span class="line"><span class="string">    3. 若激活失败，尝试从 backup_db_path 恢复原库。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    该函数假设 new_db_path 已由子进程完整写入且句柄已释放。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>将将数据处理操作放入子进程中后，子进程中的日志操作就出现了问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermissionError: [WinError 32] 另一个程序正在使用此文件，进程无法访问。:</span><br></pre></td></tr></table></figure><p>当子进程尝试访问日志文件时，会因为日志文件正在被主进程访问而导致金城江的并发问题，这种并发就不是之前用<code>loguru</code>的设置<code>enqueue=True</code>就可以解决的了。要想解决这种问题，可能需要为系统的各个进程单独设置日志系统。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于python日志系统的实现</title>
      <link href="/2025/12/08/%E5%85%B3%E4%BA%8Epython%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/12/08/%E5%85%B3%E4%BA%8Epython%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>上周，公司要我给系统添加一个日志系统，当时感觉这个比较简单，于是使用<code>logging</code>实现没有用<code>loguru</code>，由于马上就要交付项目所以写的比较急。结果在日志轮转时报错了。在原本的日志系统中我使用的是<code>TimedRotatingFileHandler</code>。</p><p>错误如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermissionError: [WinError 32] 另一个程序正在使用此文件，进程无法访问。: <span class="string">&#x27;E:\\…………\\loggings\\app.log.1&#x27;</span></span><br></pre></td></tr></table></figure><p>这个错误发生在 <code>TimedRotatingFileHandler</code> 的 <code>doRollover()</code> 方法中，当它尝试重命名日志文件（如 <code>app.log</code> → <code>app.log.1</code>）时，发现原文件被其他进程或线程“锁定”了。</p><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><p>首先，查看doRollver()方法，将其代码简化后如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">doRollover</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.stream:</span><br><span class="line">        <span class="variable language_">self</span>.stream.close()</span><br><span class="line">        <span class="variable language_">self</span>.stream = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># get the time that this sequence started at and make it a TimeTuple</span></span><br><span class="line">    dfn = <span class="variable language_">self</span>.baseFilename + <span class="string">&quot;.&quot;</span> + time.strftime(<span class="variable language_">self</span>.suffix, timeTuple)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(dfn):</span><br><span class="line">        os.remove(dfn)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="variable language_">self</span>.baseFilename):</span><br><span class="line">        os.rename(<span class="variable language_">self</span>.baseFilename, dfn)</span><br><span class="line">    <span class="variable language_">self</span>.rolloverAt = newRolloverAt</span><br></pre></td></tr></table></figure><p>注意到<strong>在执行滚动（rotate）时，需要调用 <code>os.rename()</code> 来重命名旧日志文件，但 Windows 系统不允许对正在被打开&#x2F;写入的文件进行重命名。</strong></p><p>我们所使用的python服务器是fastapi，安装了WatchFiles并启用了reload。一开始怀疑是，中途修改代码而没有使用<code>atexit.register(Log.close)</code>导致服务重启后旧句柄未释放。</p><p>但后来发现WatchFiles的重启似乎不算正常结束进程，无法触发<code>atexit.register(Log.close)</code>，这时我又想到了fastapi本身就有一定的异步特性。不过这方面因为时间原因并没有深究。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>导入loguru使用loguru库重写了日志系统，设置<code>enqueue=True</code>，这种设置能够使得日志写入操作变得异步安全，但缺点是可能会导致实时性降低。</p><p>根据查阅到的资料，其内部似乎是一种MQ的实现。即日志消息被<strong>推入线程安全队列</strong>，由 <strong>独立的后台线程</strong> 负责消费队列并写入。成功推入队列则返回写入成功，而<strong>独立的后台线程</strong>以较恒定的速度消费队列。</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code test</title>
      <link href="/2025/07/15/code-test/"/>
      <url>/2025/07/15/code-test/</url>
      
        <content type="html"><![CDATA[<p>这是一个简单python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  ANN</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> neurolab <span class="keyword">as</span> nl</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 50 个二维样本，分为 2 类</span></span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">50</span>, centers=<span class="number">2</span>, cluster_std=<span class="number">5</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化生成的数据</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, cmap=<span class="string">&#x27;coolwarm&#x27;</span>, edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Generated Input Data&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Dimension 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Dimension 2&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整标签形状以适配 neurolab</span></span><br><span class="line">y = y.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">data = X</span><br><span class="line">labels = y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制输入数据散点图</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Dimension 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Dimension 2&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输入维度范围和输出数量</span></span><br><span class="line">dim1 = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">dim2 = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">num_output = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建感知机神经网络</span></span><br><span class="line">perceptron = nl.net.newp([dim1, dim2], num_output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">error_progress = perceptron.train(data, labels, epochs=<span class="number">80</span>, show=<span class="number">20</span>, lr=<span class="number">0.03</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练误差曲线</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(error_progress)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Training error&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training error progress&#x27;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#  ANN</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> neurolab <span class="keyword">as</span> nl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">text = np.loadtxt(<span class="string">&#x27;data_simple_neural.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取输入特征和标签</span></span><br><span class="line">data = text[:, <span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">labels = text[:, <span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制原始数据散点图</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Dimension 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Dimension 2&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取输入维度范围</span></span><br><span class="line">dim1_min, dim1_max = data[:, <span class="number">0</span>].<span class="built_in">min</span>(), data[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">dim2_min, dim2_max = data[:, <span class="number">1</span>].<span class="built_in">min</span>(), data[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定输出维度数量</span></span><br><span class="line">num_output = labels.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">dim1=[dim1_min, dim1_max]</span><br><span class="line">dim2=[dim2_min, dim2_max]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建单层感知机网络</span></span><br><span class="line">nn = nl.net.newp([dim1,  dim2], num_output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练网络</span></span><br><span class="line">error_progress = nn.train(data, labels, epochs=<span class="number">100</span>, show=<span class="number">20</span>, lr=<span class="number">0.03</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练误差曲线</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(error_progress)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Training error&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training error progress&#x27;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nTest results:&#x27;</span>)</span><br><span class="line">data_test = [[<span class="number">0.5</span>, <span class="number">3.2</span>],  [<span class="number">2.9</span>, <span class="number">0.1</span>], [<span class="number">1.1</span>, <span class="number">1.9</span>], [<span class="number">2.8</span>, <span class="number">2.8</span>]]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data_test:</span><br><span class="line">    <span class="built_in">print</span>(item, <span class="string">&#x27;-&gt;&#x27;</span>, nn.sim([item])[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#  ANN</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> neurolab <span class="keyword">as</span> nl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据范围和数量</span></span><br><span class="line">min_val = -<span class="number">20</span></span><br><span class="line">max_val = <span class="number">20</span></span><br><span class="line">num_points = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成输入数据并创建目标输出</span></span><br><span class="line">x = np.linspace(min_val, max_val, num_points)</span><br><span class="line">y = <span class="number">2</span> * np.square(x) + <span class="number">7</span></span><br><span class="line">y /= np.linalg.norm(y)  <span class="comment"># 归一化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备训练数据</span></span><br><span class="line">data = x.reshape(num_points, <span class="number">1</span>)</span><br><span class="line">labels = y.reshape(num_points, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制输入数据</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(data, labels)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Dimension 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Dimension 2&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建神经网络</span></span><br><span class="line">nn = nl.net.newff([[min_val, max_val]], [<span class="number">10</span>, <span class="number">6</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置训练算法为梯度下降</span></span><br><span class="line">nn.trainf = nl.train.train_gd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练网络</span></span><br><span class="line">error_progress = nn.train(data, labels, epochs=<span class="number">1600</span>, show=<span class="number">100</span>, goal=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行预测</span></span><br><span class="line">output = nn.sim(data)</span><br><span class="line">y_pred = output.reshape(num_points)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练误差进度</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(error_progress)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training error progress&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建更密集的输入数据用于可视化预测结果</span></span><br><span class="line">x_dense = np.linspace(min_val, max_val, num_points * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测密集数据</span></span><br><span class="line">y_dense_pred = nn.sim(x_dense.reshape(x_dense.size, <span class="number">1</span>)).reshape(x_dense.size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制实际 vs 预测结果</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x_dense, y_dense_pred, <span class="string">&#x27;-&#x27;</span>, x, y, <span class="string">&#x27;.&#x27;</span>, x, y_pred, <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Actual vs predicted&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt. show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># RNN</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> neurolab <span class="keyword">as</span> nl</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">num_points</span>):</span><br><span class="line">    wave_1 = <span class="number">0.49</span> * np.sin(np.arange(<span class="number">0</span>, num_points))</span><br><span class="line">    wave_2 = <span class="number">3.62</span> * np.sin(np.arange(<span class="number">0</span>, num_points))</span><br><span class="line">    wave_3 = <span class="number">1.2</span> * np.sin(np.arange(<span class="number">0</span>, num_points))</span><br><span class="line">    wave_4 = <span class="number">4.6</span> * np.sin(np.arange(<span class="number">0</span>, num_points))</span><br><span class="line"></span><br><span class="line">    amp_1 = np.ones(num_points)</span><br><span class="line">    amp_2 = <span class="number">2</span> + np.zeros(num_points)</span><br><span class="line">    amp_3 = <span class="number">3.1</span> * np.ones(num_points)</span><br><span class="line">    amp_4 = <span class="number">0.9</span> + np.zeros(num_points)</span><br><span class="line"></span><br><span class="line">    wave = np.array([wave_1, wave_2, wave_3, wave_4]).reshape(num_points * <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">    amp = np.array([amp_1, amp_2, amp_3, amp_4]).reshape(num_points * <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wave, amp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_output</span>(<span class="params">nn, num_points_test</span>):</span><br><span class="line">    wave, amp = get_data(num_points_test)</span><br><span class="line">    output = nn.sim(wave)</span><br><span class="line">    plt.plot(amp.reshape(num_points_test * <span class="number">4</span>))</span><br><span class="line">    plt.plot(output.reshape(num_points_test * <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_points = <span class="number">50</span></span><br><span class="line">    wave, amp = get_data(num_points)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 newelm 网络</span></span><br><span class="line">    nn = nl.net.newelm([[-<span class="number">3</span>, <span class="number">3</span>]] , [<span class="number">9</span>, <span class="number">1</span>], [nl.trans.TanSig(), nl.trans.PureLin()])</span><br><span class="line">    nn.layers[<span class="number">0</span>].initf = nl.init.InitRand([-<span class="number">0.1</span>, <span class="number">0.1</span>], <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    nn.layers[<span class="number">1</span>].initf = nl.init.InitRand([-<span class="number">0.1</span>, <span class="number">0.1</span>], <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    nn.init()</span><br><span class="line"></span><br><span class="line">    error_progress = nn.train(wave, amp, epochs=<span class="number">1200</span>, show=<span class="number">100</span>, goal=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">    output = nn.sim(wave)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">221</span>)</span><br><span class="line">    plt.plot(error_progress)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Number of Epochs&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.plot(amp.reshape(num_points * <span class="number">4</span>))</span><br><span class="line">    plt.plot(output.reshape(num_points * <span class="number">4</span>))</span><br><span class="line">    plt.legend([<span class="string">&#x27;Original&#x27;</span>, <span class="string">&#x27;Predicted&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">223</span>)</span><br><span class="line">    visualize_output(nn, <span class="number">83</span>)</span><br><span class="line">    plt.xlim([<span class="number">0</span>, <span class="number">300</span>])</span><br><span class="line">    plt.subplot(<span class="number">224</span>)</span><br><span class="line">    visualize_output(nn, <span class="number">48</span>)</span><br><span class="line">    plt.xlim([<span class="number">0</span>, <span class="number">300</span>])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># LSTM</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> neurolab <span class="keyword">as</span> nl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置参数</span></span><br><span class="line">input_file = <span class="string">&#x27;letter.data&#x27;</span></span><br><span class="line">num_datapoints = <span class="number">40</span></span><br><span class="line">orig_labels = <span class="string">&#x27;encode&#x27;</span>  <span class="comment"># 注意：这里保留原始字符串，不去除空格</span></span><br><span class="line">num_orig_labels = <span class="built_in">len</span>(orig_labels)</span><br><span class="line"></span><br><span class="line">num_train = <span class="built_in">int</span>(<span class="number">0.9</span> * num_datapoints)</span><br><span class="line">num_test = num_datapoints - num_train</span><br><span class="line">start = <span class="number">6</span></span><br><span class="line">end = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据容器</span></span><br><span class="line">data = []</span><br><span class="line">labels = []</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            list_vals = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)  <span class="comment"># 假设分隔符是 &#x27;&lt;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> list_vals[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> orig_labels:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            label = np.zeros((num_orig_labels, <span class="number">1</span>))</span><br><span class="line">            label[orig_labels.index(list_vals[<span class="number">1</span>])] = <span class="number">1</span></span><br><span class="line">            labels.append(label)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 提取特征向量</span></span><br><span class="line">            cur_char = np.array([<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> list_vals[start:end]])</span><br><span class="line">            data.append(cur_char)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) &gt;= num_datapoints:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转换为 NumPy 数组</span></span><br><span class="line">    data = np.asfarray(data)</span><br><span class="line">    labels = np.array(labels).reshape(num_datapoints, num_orig_labels)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 神经网络配置</span></span><br><span class="line">    num_dims = <span class="built_in">len</span>(data[<span class="number">0</span>])</span><br><span class="line">    nn = nl.net.newff([[<span class="number">0</span>, <span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data[<span class="number">0</span>]))], [<span class="number">128</span>, <span class="number">16</span>, num_orig_labels])</span><br><span class="line">    nn.trainf = nl.train.train_gd</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    error_progress = nn.train(data[:num_train, :], labels[:num_train, :],</span><br><span class="line">                              epochs=<span class="number">5000</span>, show=<span class="number">500</span>, goal=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试模型</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTesting on unknown data:&#x27;</span>)</span><br><span class="line">    predicted_test = nn.sim(data[num_train:, :])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_test):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\nOriginal:&#x27;</span>, orig_labels[np.argmax(labels[i])])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Predicted:&#x27;</span>, orig_labels[np.argmax(predicted_test[i])])</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: File &#x27;<span class="subst">&#123;input_file&#125;</span>&#x27; not found.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;An error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/07/15/hello-world/"/>
      <url>/2025/07/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
